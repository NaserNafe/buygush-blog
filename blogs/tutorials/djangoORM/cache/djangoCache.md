# Django’s cache framework  فریم فرک کش جنگو

نکته مثیت یک وبسایت دانامیک خب داینامیک بودن سایته. هر موقه که یک کاربر یک پیجی را ریکوست میکند، وب سرور همه جوره محاسباتی انجام میده از کوئری زدن به دیتابیس بگیر تا رندر کردن تمپلیت ها و لاجیک مربوط به بیزینس تا کاربر سایت را مشاهده کند.
از دیدگاه سربار پردازش، این بسیار گران‌تر از چیدمان سرور استاندارد خواندن یک فایل خارج از فایل سیستم (standard read-a-file-off-the-filesystem server arrangement روشی برای خواندن اطلاعات بدون پردازش) شما است.
برای بسیاری از وب اپلیکیشن ها این سربار مسئله بسیار مهمی نیست. همه اپلیکیشن ها که سایت واشینگتون پست یا سایت اسلش دات او آرجی نیستند.آنها اکثرا اپی بین کوچک تا متوسط سایز با ترافیک متوسط هستند. اما برای سایت های پر ترافیک خیلی ضروری است تا سربار را تا حد ممکن کاهش داد.
اینجاست که کش کردن بسیار کمک کننده است.

کش کردن یعنی ذخیره کردن نتایج محاسبات پرهزینه است تا بار دیگر این محاسبات صورت نگیرد.
جنگو دارای سیسم کشینگ قوی است که اجازه ذخیره پیج های داینامیک را میدهد تا دوباره محاسبات از اول صورت نگیرد.

جنگو جهت سهولت سطح جزئیات کش مختلفی ارائه می دهد.
شما می توانید خروجی ویوهای ویژه را کش کنید، شما می توانیدفقط یک تکه که تولید آن سخت است یا کل سایت را کش کنید.

جنگو همچنین با داون استریمرکش ها مثل **Squid** و **browser-based** به خوبی کار می کند.

___
## Setting up the cache   تنظیم کردن کش

سیستم کش نیاز به مقدار کم از تنظیمات نیاز دارد. برای نمونه شما باید مشخص کنید کجا باید اطلاعات زندگی کنند، در دیتابیس یا فایل سیستم و یا مستقیم در مموری. این یک تصمیم مهمی است که تاثیر بسزایی در پرفرمنس کش دارد. بعضی از کش ها سریع تر از دیگری عمل می کنند.

ترجیحات مربوط به کش در فایل ستینگ <a href="/blogs/tutorials/djangoORM/settings/settingsFile.md#caches">Cache</a>  نوشته می شود.

___
## Memcached

ممکش یک سرور کاملا مموری بیس است که اساسا توسعه یافت تا لود بسیار بالا در سایت **LiveJournal.com** را هندل کند و در نتیجه توسط اینتراکتیو جنگو اوپن سورس شد. توسط سایت های مثل  **Facebook** و **Wikipedia** استفاده گردید تا دسترسی به دیتابیس را کاهش و پرفرمنس سایت ها را بالا برد.

ممکش به شکل دیمن یعنی در بکگراند اجرا می شود و مقدار رم زیادی را به خود اختصاص می دهد. همه کاری که انجام می دهد این است که یک اینترفیس بسیار سریع برای افزودن و بازخوانی و حذف دیتا در کش ارائه می دهد. همه دیتا در مستقیما در مموری ذخیره می شود پس سرباری به فایس سیسنم و دیتابیس ندارد.

بعد از نصب خود **Memcached** نیاز به نصب بایند کننده ممکش است. تعدادی بایند ممکش برای پایتون موجود است که جنگو از دو مورد **pylibmc** و **pymemcache** پشتیبانی می کند.

برای استفاده از ممکش با جنگو؛
- بسته به انتخاب بایندینگ باید **django.core.cache.backends.memcached.PyMemcacheCache** یا **django.core.cache.backends.memcached.PyLibMCCache** را در **BACKEND** فایل ستینگ باید ست گردد. 
- و قسمت **LOCATION** به شکل **ip:port** که آی پی آی پی آدرس ممکش در بکگراند و پورت هم  به پورت ممکش کی در حال اجرا است باید ست شود. ویا به شکل  **unix:path** باید نوشته شود که پس مسیر Memcached Unix socket file است.
  
```python
CACHES = {
    "default": {
        "BACKEND": "django.core.cache.backends.memcached.PyMemcacheCache",
        "LOCATION": "127.0.0.1:11211",
    }
}
```
```python
CACHES = {
    "default": {
        "BACKEND": "django.core.cache.backends.memcached.PyMemcacheCache",
        "LOCATION": "unix:/tmp/memcached.sock",
    }
}
```

یک ویژگی عالی ممگش توانایی آن در شییر کردن بر روی چندین سرور است. یعنی ممکش  دیمون را می توان روی چند ماشین اجرا کرد، وبرنامه انگار فقط با یک ماشین سر و کار دارد، بدون اینکه مقادیر کش را در ماشین ها تکرار کرد.
برای بهره بردن از این توانایی باید همه آدرس های سرور ها را در **LOCATION** نوشت چه به شکل یک لیست  ویا چه به شکل جدا کننده کما ویا سمی کولن در سترینگ.

```python
CACHES = {
    "default": {
        "BACKEND": "django.core.cache.backends.memcached.PyMemcacheCache",
        "LOCATION": [
            "172.19.26.240:11211",
            "172.19.26.242:11211",
        ],
    }
}
```
```python
CACHES = {
    "default": {
        "BACKEND": "django.core.cache.backends.memcached.PyMemcacheCache",
        "LOCATION": [
            "172.19.26.240:11211",
            "172.19.26.242:11212",
            "172.19.26.244:11213",
        ],
    }
}
```
به طور پیش فرض **PyMemcacheCache** بک اند آپشن های زیر را ست می کند. برای اورراید کردن آنها <a href="/blogs/tutorials/djangoORM/settings/settingsFile.md#">OPTIONS</a>

___
## Cache arguments

به هر کش بک اندی می توان آرگیومنت های اضافی داد برای کنترل رفتار کش داد. این آرگیومنت ها به عنوان کلید های اضافی در <a href="/blogs/tutorials/djangoORM/settings/settingsFile.md#caches">CACHES</a> ارائه می شوند. مقادیر معتبر آرگیومنت ها عبارنتد از:

- **TIMEOUT**:

مقدار پیشفرض  تایم اوت به ثانیه و برای استفاده در کش است.
که مقدار **۳۰۰* ثانیه یا ۵ دقیقه است. می توان تایم اوت را به نان ست کرد که کلید کش هرگز منقضی نخواهد شد. مقدار را صفر قرار پاپن باعث منقضی شدن بلافاصله خواهد که عملا کشی صورت نخواهد گرفت.

- **OPTIONS** 

هر آپشنی که باید به بک اند کش تحویل داده شود.لیست موارد مجاز بسته به هر بک اندی متفاوت است، و کش بک اند با یک لایبرری پشتیبانی می شود آپشن های آن از اینجا گرفته خواهد شد.
هر کش بک اندی ستراتژی جمع آوری اطلاعات خود را بع کر می بندد.
**locmem, filesystem** و **database** آپشن های زیر را معتبر می دانند.
+ **MAX_ENTRIES** 
  ماکزیمم تعداد ورودی های مجاز کش قبل از اینکه مقادیر کهنه پاک شوند. مقدار پیشفرض آن ۳۰۰ می باشد.

+ **CULL_FREQUENCY** 
  کسری از مقادیر که در زمان رسیدن به مقدار ماکزیمم جمع آوری می شود. مقدار نسبت یک بر **CULL_FREQUENCY** خواهد بود. با ست کردن **CULL_FREQUENCY** به ۲ عمل جمع آوری نصف مقادیر وقتی به ماکز میرسد اتفاق خواهد افتاد. مقدار پیشفرض ۳ است که ورودی حتما باید یک اینتیجر باشد.

  مقار را به صفر ست کردن یعنی همه ورودی ها وقتی به ماکز رسیدند خالی خواهد شد. در بعضی از بک اند ها مثل دیتابیس به ویژه صفر قرار دادن باعث افزایش سرعت خواهد شد اما به قیمت از دست دادن اطلاعات.

بک اند های ممکش و ردیس آپشن ها را به شکل کیوردآرگیومنت به کلاینت کانستراکتور تحویل می دهند که کنترل پیشرفته ای روی رفتار کلاینت دارد.

- **KEY_PREFIX** 
  
یک استرینگ که اتوماتیک شامل (پیش فرض به ابتدای آن افزوده خواهد شد) همه کلید های کش استفاده شده توسط سرور جنگو است

- **VERSION** 
  
  مقدار دیفالت شماره ورژن برای کلید های تولید شده کش توسط سرور جنگو.

- **KEY_FUNCTION** 

    یک رشته شامل آدرس نقطه دار یک فانکشن یا هر چیز قابل صدا زدن، که تعریف می کند چگونه  یک پرفیکس  و ورژن . کلید را برای کلید نهایی کش سرهم کند.

در این مثال فایل سیستم پیکربندی می شود.
```python
CACHES = {
    "default": {
        "BACKEND": "django.core.cache.backends.filebased.FileBasedCache",
        "LOCATION": "/var/tmp/django_cache",
        "TIMEOUT": 60,
        "OPTIONS": {"MAX_ENTRIES": 1000},
    }
}
```
یک مثال از پیکر بندی **pylibmc** بک اند که پورتکل احراض هویت SASL و مد رفتاری **ketama** را فعال می کند.  
```python
CACHES = {
    "default": {
        "BACKEND": "django.core.cache.backends.memcached.PyLibMCCache",
        "LOCATION": "127.0.0.1:11211",
        "OPTIONS": {
            "binary": True,
            "username": "user",
            "password": "pass",
            "behaviors": {
                "ketama": True,
            },
        },
    }
}
```
در این مثال پیکربندی برای **pymemcache** که نظرسنجی از کاربر که محتملا موجب افزایش پرفرمنس با در ارتباط نگهداشتن کلاینت را فعال میکند.ابرادات ممکش یا نتورک را مثل کش از دست رفته فرض میکند و فلق **TCP_NODLAY** در کانکشن سوکت ست می کند.


```python
CACHES = {
    "default": {
        "BACKEND": "django.core.cache.backends.memcached.PyMemcacheCache",
        "LOCATION": "127.0.0.1:11211",
        "OPTIONS": {
            "no_delay": True,
            "ignore_exc": True,
            "max_pool_size": 4,
            "use_pooling": True,
        },
    }
}
```
یک مثال از پیکر بندی ردیس
```python
CACHES = {
    "default": {
        "BACKEND": "django.core.cache.backends.redis.RedisCache",
        "LOCATION": "redis://127.0.0.1:6379",
        "OPTIONS": {
            "db": "10",
            "parser_class": "redis.connection.PythonParser",
            "pool_class": "redis.BlockingConnectionPool",
        },
    }
}
```
