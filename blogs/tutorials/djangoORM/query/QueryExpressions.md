# Query Expressions عبارات کوئری 
عبارات کوئری یک مقدار یا یک محاسبه را توصیف می کند که میتوان به عنوان بخشی از یک **update, create, filter, order by, annotation** و یا **aggregate** استفاده کرد.
وقتی که  خروجی یک عبارت مقدار بولیین است ممکن است مستقیم در فیلتر استفاده شود.
تعدادی عبارت از پیش ساخته شده وجود دارد که در زیر لیست می شود، می توانند برای کويری نوشتن کمک کنند. 
این عبارات می توانند ترکیب شوند یا در بعضی موارد برای ساخت کوئری پیچیده زنجیر شوند.

___
## Supported arithmetic عملیات ریاضی 

جنگو از عملیات ریاضی مثل منفی کردن، جمع و تفریق، ضرب و تقسیم،باقیمانده تقسیم و توان رسانی را ساپورت می کند.
___
## Output field نوع فیلد خروجی
بسیاری از عبارات ذکر شده در زیر پارامتری آپشنال به اسم **output_field** دارند. که در صورت دادن این آپشن جنگو مقدار را بعد از بازخوانی از دیتابیس با تایپ لود خواهد کرد.
```python
from django.db.models import FloatField, F, Sum
total_group = Sum(F('total_sold')*F('final_price'), output_field=FloatField())
```
**output_field** اینستنسی از مدل فیلد را میگیرد مثل:
**IntegerField() یا BooleanField()**.
معمولا این فیلد نیازی به هیچ آرگیومنتی ندارد مثل **max_length** چون این ولیدیشن در مقدار خروجی اعمال نخواهد شد.

**output_field** فقط زمانی ضروری خواهد شد که جنگو نمی تواند تایپ فیلد خروجی را نداند. مثا عبارات پیچیده که چندین فیلد ترکیب شده اند. مثل جمع یک **DecimalField()** و یک **FloatField()** به یک **output_field**نیاز داردنمی داند خروجی چیست 
___
# Built-in Expressions عبارات از پیش ساخته شده

> این عبارات پر **django.db.models.expressions and django.db.models.aggregates** تعریف شده اند ام جهت سادگی از **django.db.models** هم قابل دسترسی هستند.
ـــ
## F() expressions
آبجکت کلاس اف بیانگر مقدار فیلد مدل یا مقدار تغییر یافته مدل و یا انوتیت شده یک ستون است.
اف ارجاع به مقدار فیلد یک مدل و اجرای عملیات دیتابیسی با استفاده کردن آنها بدون اینکه مجبور شود اطلاعات را خارج از دیتابیس بیاورد و به حافظه پایتون ارسال کند.

بجای آن، جنگو از آبجکت **اف** برای تولید عبارت اس کیو الی که عملیات مورد نیاز در سطح دیتابیس را توصیف می کند استفاده می کند.

با توجه به مثال زیر در حالت نرمال به شکل زیر عمل می شود.

```python
# Tintin filed a news story!
reporter = Reporters.objects.get(name="Tintin")
reporter.stories_filed += 1
reporter.save()
```
در اینجابا استفاده از عملیات پایتونی بر روی اطلاعاتی که از دیتابیس استخراج و به مموری  پایتون انتقال داده شده است اطلاعات دیتابیس تغیر و به دیتابیس بر گردانده می شود.
اما در عوض می توان به شکل زیر انجام داد.
```python
from django.db.models import F

reporter = Reporters.objects.get(name="Tintin")
reporter.stories_filed = F("stories_filed") + 1
reporter.save()
``` 
 گرچه **reporter.stories_filed = F('stories_filed') + 1** شبیه یک اساینمنت معمولی  مقدار پایتون به انستنس اتریبیوت نظر می رسد. در حقیقت یک ساختار اسکیو الی است که یک عملیاتی را در دیتابیس توصیف می کند.

 وقتی که جنگو با اینستنسی از **اف** مواجه می شود، عملیات پایتونی را برای ایجاد یک عبارت اسکیو الی کپسوله شده جایگزین می کند. 
 در مثال بالا دیتابیس را برای افزایش یک فیلد دیتابیس که با **reporter.stories_filed** نمایش داده می شود سازماندهی می کند.

 هر مقداری که  در **reporter.stories_filed** است یابود پایتون هرگز در مورد ان خبردار نمی شود.
 با آن کلا فقط دیتابیس سروکله می زند.
 همه چیزی که پایتون از طریق **اف** انجام می دهد ایجاد سنتکس اسکیوالی برای ارجاع به فیلد و تعریف عملیات روی آن است.
 برای دسترسی به مقدار ذخیره شده جدید به این شکل این است که آبجکت پایتونی باید دوباره بارگیری شود.
 ```python
 reporter = Reporters.objects.get(pk=reporter.pk)
# Or, more succinctly:
reporter.refresh_from_db()
 ```
علاوه بر استفاده شدن در عملیات ها روی یک اینستنس، **اف** را می شود روی کوئری ست  با **update()** روی چند ابجکت اینستنس استفاده کرد. این دو کوئری **get()** و **save()** بالا را به یک کوئری کاهش می دهد.

```python
reporter = Reporters.objects.filter(name="Tintin")
reporter.update(stories_filed=F("stories_filed") + 1)
```
همچنین با استفاده از **update()**  مقدار فیلد روی چند آبجکت را ارتقاء داد که می تواند بسیار سریع تر از انتقال همه به پایتون و پیمایش روی اونها و ارتقاء مقادیر فیلد ها و ذخیره دوباره آنها در دیتابیس.
```python
Reporter.objects.update(stories_filed=F("stories_filed") + 1)
```
در مثال بالایی روی **Tintin** فیلتر شده است اما در مثال پایینی روی کل فیلد **stories_filed** ارتقاء می دهد.

> لذا **اف** برای افزایش کارایی مزایای به کمک موارد زیر دارد.
>1. سر کار با دیتابیس بجای پایتون.
>2. کاهش تعداد کوئری ها که بعضی از عملیات نیاز دارند.

___

## Avoiding race conditions using F() اجتناب از ریس کاندیشن با استفاده از **اف**

یکی دیگر از مزیت های **اف** چون با دیتابیس کار میکند بجای پایتون این است که فیلدها را آپدیت میکند بدپن اینکه ریس کاندیشن رخ دهد.
هر کدام از **thread** ترت های پایتون زمانی که روی یک مقدار فیلد کار میکنند ممکن است یک ترت ارتقاء را نجام دهد ولی ترت دیگری خبردار  نباشد و دوباره مقدار افزایش یافته را دوباره ارتقاء دهد.
اما اگر دیتابیس مسئول آپدیت باشد بجای منتظر ماند برای **save() or update()** که اجرا شوند همان لحظه بازخوانی عملیات انجام میشود. و جلوی ریس کاندیشن گرفته می شود.

___
## F() assignments persist after Model.save() اف حتی بعد از سیو مدل هم به قوت خود باقی می ماند.

آبجکت اف بعد از صدا زدن سیو دوباره میماند و در هر صدا زدن دوباره متد سیو مکررا اعمال می شود.

```python
reporter = Reporters.objects.get(name="Tintin")
reporter.stories_filed = F("stories_filed") + 1
reporter.save()

reporter.name = "Tintin Jr."
reporter.save()
```
مقدار **stories_filed** دو بار آپدیت خواهد شد. اگر مقدار اولیه ۱ باشد مقدار نهایی به ۳ تغییر خواهد یافت.
این ماندگاری به وسیله بارگیری دوباره آبجکت مدل بعد از فراخوانی متد سیو به کمک **refresh_from_db()** قابل اجتناب است.


